// Load tickers and prices from JSON
const tickersUrl = "https://raw.githubusercontent.com/matthewpres/JSE-Sentiment/main/tickers.json";
let stockPrices = {};

fetch(tickersUrl)
    .then(response => response.json())
    .then(data => {
        stockPrices = data;
        console.log("Stock Prices Loaded:", stockPrices);
        updateAutocomplete();
        renderPredictionTable();
    })
    .catch(error => console.error("Error loading tickers:", error));

// Update autocomplete with tickers
function updateAutocomplete() {
    const tickerInput = document.getElementById("tickerInput");
    const datalist = document.getElementById("tickerList");
    datalist.innerHTML = "";
    Object.keys(stockPrices).forEach(ticker => {
        let option = document.createElement("option");
        option.value = ticker;
        datalist.appendChild(option);
    });
}

// Show market price when ticker is selected
function showCurrentPrice(ticker) {
    const price = stockPrices[ticker];
    document.getElementById("currentPriceDisplay").textContent =
        price ? `Current Market Price: $${price.toFixed(2)}` : "Market price not available";
}

document.getElementById("tickerInput").addEventListener("input", function () {
    showCurrentPrice(this.value.toUpperCase());
});

// Submit prediction
function addPrediction() {
    const ticker = document.getElementById("tickerInput").value.toUpperCase();
    const predictionPrice = parseFloat(document.getElementById("priceInput").value);
    const errorMessageEl = document.getElementById("errorMessage");
    
    if (!ticker || isNaN(predictionPrice) || !(ticker in stockPrices)) {
        errorMessageEl.textContent = "Invalid ticker or missing price.";
        return;
    }

    console.log("Prediction added:", { ticker, predictionPrice });

    predictionsRef.push({
        ticker: ticker,
        currentPrice: stockPrices[ticker],
        predictionPrice: predictionPrice,
        timestamp: firebase.database.ServerValue.TIMESTAMP
    });

    errorMessageEl.textContent = "Prediction submitted successfully!";
    errorMessageEl.style.color = "green";
    document.getElementById("tickerInput").value = "";
    document.getElementById("priceInput").value = "";

    renderPredictionTable();
}

document.getElementById("submitPrediction").addEventListener("click", addPrediction);

// Render predictions
function renderPredictionTable() {
    predictionsRef.once("value", snapshot => {
        const predictionsData = snapshot.val();
        const predictionsBody = document.getElementById("predictionsBody");
        predictionsBody.innerHTML = "";
        
        let aggregatedPredictions = {};
        
        Object.values(predictionsData || {}).forEach(entry => {
            if (!aggregatedPredictions[entry.ticker]) {
                aggregatedPredictions[entry.ticker] = { count: 0, total: 0, min: entry.predictionPrice, max: entry.predictionPrice };
            }
            let record = aggregatedPredictions[entry.ticker];
            record.count++;
            record.total += entry.predictionPrice;
            record.min = Math.min(record.min, entry.predictionPrice);
            record.max = Math.max(record.max, entry.predictionPrice);
        });

        Object.keys(aggregatedPredictions).forEach(ticker => {
            let record = aggregatedPredictions[ticker];
            let avgPrice = record.total / record.count;
            let currentPrice = stockPrices[ticker] || "N/A";
            let row = document.createElement("tr");
            row.innerHTML = `
                <td>${ticker}</td>
                <td>${currentPrice !== "N/A" ? `$${currentPrice.toFixed(2)}` : "N/A"}</td>
                <td>$${avgPrice.toFixed(2)}</td>
                <td>${currentPrice !== "N/A" ? `${((avgPrice - currentPrice) / currentPrice * 100).toFixed(2)}%` : "N/A"}</td>
                <td>${record.count}</td>
            `;
            row.addEventListener("click", () => renderPriceTargetChart(ticker, record.min, avgPrice, record.max, currentPrice));
            predictionsBody.appendChild(row);
        });
    });
}

// Render price target chart
function renderPriceTargetChart(ticker, min, avg, max, currentPrice) {
    const chartContainer = document.getElementById("priceTargetChart");
    chartContainer.innerHTML = `<h3>Price Target Range for ${ticker}</h3>`;
    
    const canvas = document.createElement("canvas");
    chartContainer.appendChild(canvas);
    
    new Chart(canvas, {
        type: "scatter",
        data: {
            datasets: [{
                label: "Price Targets",
                data: [
                    { x: min, y: 0 },
                    { x: avg, y: 0 },
                    { x: max, y: 0 },
                    { x: currentPrice, y: 0 }
                ],
                backgroundColor: ["black", "blue", "black", "green"],
                pointRadius: [5, 7, 5, 7],
            }]
        },
        options: {
            scales: {
                x: {
                    type: "linear",
                    position: "bottom"
                },
                y: {
                    display: false
                }
            }
        }
    });
}
